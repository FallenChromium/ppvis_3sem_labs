## Древовидное представление и интерпретация теоретико-множественных выражений

При выборе этого варианта студенту необходимо разработать объектную модель для пред-
ставления теоретико-множественных выражений в виде дерева и реализовать программу-калькулятор, которая осуществляет вычисления выражений такого типа.

Рассмотрение этого варианта начнем с примера работы программы (бирюзовым цветом выделен ввод от пользователя, черным цветом – вывод программы, символ «?» обозначает нажатие клавиши Enter):
```
? {a, b, c} ?
= {a, b, c}
? {a, b, c} + {a, b, d} ?
= {a, b, c, d}
? {a, b, c} * {a, b, d} ?
= {a, b}
? B = A = {a, b, c} ?
= {a, b, c}
? B – A ?
= {}
? {a} + {} * ( ( {} + {a, {a, b}} ) ) ?
= {a, {a, b}}
? Boolean( {a, b} ) ?
= {{}, {a}, {b}, {a, b}}
? Boolean( {a, b}, {a} ) ?
^
Error: Function ‘Boolean’ expects 1 argument, but you pass 2.
? {a} + ?
^

Error: Expect variable name, function call or set definition.
```


Из приведенной сессии работы можно сформулировать возможности калькулятора:

- Вычисление теоретико-множественных выражений с использованием операций объедине-
ния (+), пересечения (*) и симметрической разности (-) множеств. Причем приоритет этих операций должен задаваться при помощи скобок.

- Возможность использования заранее определенных функций обработки множество (на-
пример, функции Boolean с одним аргументом).

- Возможность установки результата вычисления выражения в качестве значения переменных.

- Указания места ошибки и сообщения об ошибке при некорректном вводе.

Для более формального описания синтаксиса выражений воспользуемся Расширенной формой Бэкуса-Наура (РБНФ). Грамматика для наших выражений будет иметь следующий вид:
```
<предложение> ::= [ <присвоение> ] <выражение>
<присвоение> ::= <имя_переменной> ‘=’
<выражение> ::= <терм_выражение> [ <операция> <выражение> ]
<терм_выражение> ::= <множество>
| <имя_переменной>
| <вызов_функции>
| ‘(’ <выражение> ‘)’
<множество> ::= ‘{’ [ <элемент> [ ‘,’ <элемент> ] ] ‘}’
<элемент> ::= <имя> | <множество>
<имя_переменной> ::= <имя>
<вызов_функции> ::= <имя> ‘(’ [ <выражение> [ ‘,’ <выражение> ] ] ‘)’
<операция> ::= ‘+’ | ‘*’ | ‘-’
<имя> ::= <цифра> | <буква>
[ <буква> | ‘_’ | <цифра> ]
<цифра> ::= ‘0’ | ... | ‘9’
<буква> ::= ‘A’ | ... | ‘z’
```
Разработанная объектная модель в этом варианте должна обеспечивать представление в
памяти в виде дерева и вычисление описанных выше теоретико-множественных выражений.
Таким образом, сформулируем более четко требования к объектной модели и реализованной
программе. Объектная модель должна соответствовать следующим требованиям:
- включать классы разбора выражения из текстового представления;

- включать классы представления дерева разобранного выражения и вершин дерева раз-
личных типов;

- включать классы, обеспечивающие поддержку использования переменных в выражениях;
- включать классы для представления и регистрации функции на C++;

- включать классы для интерпретации выражений; включать классы исключений для сигнализации об ошибках.

Реализованная на основе разработанной модели программа должна:
- проводить диалог с пользователем, в процессе которого происходит вычисление введенных
выражений;
- выводить сообщения об ошибках при получении некорректного ввода от пользователя.

Совет:
По рекомендации преподавателя можно изучить главу 2 из книги «А. Ахо, Р. Сети, Дж. Ульман – Компиляторы: Принципы, технологии, инструменты». В этой главе можно ознакомиться с методом рекурсивного спуска для разбора арифметических выражений и примером его реализации на языке программирования С.
Если студент последует этому совету, то ему необходимо обратить внимание на то, что
приведенная выше грамматика не адаптирована для метода рекурсивного спуска.

Упрощение:
По рекомендации преподавателя студент может выполнить упрощенную версию данного
вариант. В упрощенной версии исключается возможность использования функций обработки
во введенных выражениях.